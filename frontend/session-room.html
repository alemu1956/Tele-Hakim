<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TeleDoctor - Secure Video Consultation</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            text-align: center;
            margin-top: 50px;
            background: #f0f2f5;
            color: #333;
        }

        video {
            border: 2px solid #ddd;
            width: 48%;
            max-width: 640px;
            height: auto;
            margin: 1%;
            background-color: #000;
            border-radius: 8px;
        }

        .status {
            margin: 20px;
            font-size: 1.1em;
            font-weight: bold;
            color: #1a2a6c;
        }

        input,
        button {
            padding: 12px 20px;
            font-size: 16px;
            margin: 8px;
            border-radius: 5px;
            border: 1px solid #ccc;
        }

        button {
            background-color: #1a2a6c;
            color: white;
            border: none;
            cursor: pointer;
        }

        button:disabled {
            background-color: #a0a0a0;
            cursor: not-allowed;
        }

        #video-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }
    </style>
</head>

<body>

    <h1>TeleDoctor - Secure Video Consultation</h1>

    <div class="status" id="statusText">Please grant permission to use your camera and microphone.</div>

    <div id="permission-section">
        <button id="accessBtn">Allow Camera & Microphone</button>
    </div>

    <div id="video-section" style="display:none;">
        <div id="video-container">
            <video id="localVideo" autoplay playsinline muted></video>
            <video id="remoteVideo" autoplay playsinline></video>
        </div>

        <div>
            <input id="roomInput" placeholder="Enter Room ID">
            <button onclick="joinRoom()">Join Room</button>
        </div>

        <div>
            <button id="startRecord" disabled>Start Recording</button>
            <button id="stopRecord" disabled>Stop Recording</button>
        </div>
    </div>

    <script>
        const accessBtn = document.getElementById('accessBtn');
        const permissionSection = document.getElementById('permission-section');
        const videoSection = document.getElementById('video-section');
        const statusText = document.getElementById('statusText');
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const roomInput = document.getElementById('roomInput');
        const startRecordBtn = document.getElementById('startRecord');
        const stopRecordBtn = document.getElementById('stopRecord');

        let localStream, remoteStream, peerConnection, roomId, mediaRecorder, recordedChunks = [];

        // ✅ FIX 1: Use a Secure WebSocket (wss://).
        // This requires your WebSocket server to be configured with an SSL certificate.
        const ws = new WebSocket('wss://192.168.1.170:8080');

        const servers = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                // ✅ FIX 2: Use a secure TURN server (turns://) and REAL credentials.
                // Replace 'user' and 'pass' with your actual TURN server credentials.
                { urls: 'turns:2.96.207.159:3478', username: 'user', credential: 'pass' }
            ]
        };

        accessBtn.addEventListener('click', async () => {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                localVideo.srcObject = localStream;
                permissionSection.style.display = 'none';
                videoSection.style.display = 'block';
                statusText.textContent = "Camera & Microphone access granted. Enter a Room ID to begin.";
            } catch (error) {
                statusText.textContent = "Permission denied. Please allow camera/mic access in browser settings.";
                console.error("getUserMedia Error:", error);
            }
        });

        async function joinRoom() {
            roomId = roomInput.value.trim();
            if (!roomId) { statusText.textContent = "Please enter a valid Room ID."; return; }
            statusText.textContent = `Connecting to room: ${roomId}...`;
            await createPeer();
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            ws.send(JSON.stringify({ room: roomId, type: 'offer', offer }));
        }

        async function createPeer() {
            peerConnection = new RTCPeerConnection(servers);
            localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

            peerConnection.ontrack = (event) => {
                remoteStream = event.streams[0];
                remoteVideo.srcObject = remoteStream;
                checkReadyForRecording();
            };

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    ws.send(JSON.stringify({ room: roomId, type: 'candidate', candidate: event.candidate }));
                }
            };

            peerConnection.onconnectionstatechange = () => {
                statusText.textContent = `Connection state: ${peerConnection.connectionState}`;
                console.log("Connection state:", peerConnection.connectionState);
                if (peerConnection.connectionState === 'connected') {
                    statusText.textContent = "Doctor connected - Session started.";
                } else if (peerConnection.connectionState === 'failed') {
                    statusText.textContent = "Connection failed. Please check network and TURN server settings.";
                }
            };
        }

        ws.onmessage = async (event) => {
            const message = JSON.parse(event.data);
            if (!roomId || message.room !== roomId) return;

            if (message.type === 'offer') {
                await createPeer();
                await peerConnection.setRemoteDescription(new RTCSessionDescription(message.offer));
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                ws.send(JSON.stringify({ room: roomId, type: 'answer', answer }));
            } else if (message.type === 'answer') {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(message.answer));
            } else if (message.type === 'candidate') {
                await peerConnection.addIceCandidate(message.candidate);
            }
        };

        function checkReadyForRecording() {
            if (localStream && remoteStream) {
                startRecordBtn.disabled = false;
            }
        }

        startRecordBtn.addEventListener('click', () => {
            // ... (Your recording logic is fine, but the upload must also be to an HTTPS endpoint) ...
            // ✅ FIX 3: Ensure your upload server is also on HTTPS.
            // Example: `https://192.168.1.170:3000/upload-audio`
        });

        // The rest of your recording logic can remain the same.
        stopRecordBtn.addEventListener('click', () => {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            }
        });
        // (Full recording logic omitted for brevity, your existing logic is okay)
    </script>

</body>

</html>